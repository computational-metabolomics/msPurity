% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/purityA-filter-frag-spectra.R
\name{filterFragSpectra,purityA-method}
\alias{filterFragSpectra,purityA-method}
\alias{filterFragSpectra}
\title{Filter fragmentations spectra associated with an XCMS feature}
\usage{
\S4method{filterFragSpectra}{purityA}(
  pa,
  ilim = 0,
  plim = 0.8,
  ra = 0,
  snr = 3,
  rmp = FALSE,
  snmeth = "median",
  allfrag = FALSE
)
}
\arguments{
\item{pa}{object; purityA object}

\item{ilim}{numeric; min intensity of a peak}

\item{plim}{numeric; min precursor ion purity of the associated precursor for fragmentation spectra scan}

\item{ra}{numeric; minimum relative abundance of a peak}

\item{snr}{numeric; minimum signal-to-noise of a peak within each file}

\item{rmp}{boolean; TRUE if peaks are to be removed that do not meet the threshold criteria. Otherwise they will just be flagged.}

\item{snmeth}{character; Method to calculate signal to noise ration (either median or mean)}

\item{allfrag}{boolean; Whether to filter on all fragmentation spectra or just the fragmentation spectra grouped to XCMS feature}
}
\value{
Returns a purityA object with the pa@grped_msms spectra matrices are updated with the following columns
\itemize{
\item snr: Signal to noise ratio (calculated at scan level)
\item ra: Relative abundance (calculated at scan level)
\item purity_pass_flag: Precursor ion purity flag (1 pass, 0 fail)
\item intensity_pass_flag: Intensity flag (1 pass, 0 fail)
\item snr_pass_flag: Signal-to-noise pass flag (1 pass, 0 fail)
\item ra_pass_flag: Relative abundance pass flag (1 pass, 0 fail)
\item pass_flag: Overall pass flag, all flags must pass for this to pass (1 pass, 0 fail)
}
}
\description{
\strong{General}

Flag and filter features based on signal-to-noise ratio, relative abundance, intensity threshold and purity of the precursor ion.

\strong{Example LC-MS/MS processing workflow}

The purityA object can be used for further processing including linking the fragmentation spectra to XCMS features, averaging fragmentation, database creation and spectral matching (from the created database). See below for an example workflow
\itemize{
\item Purity assessments
\itemize{
\item (mzML files) -> purityA -> (pa)
}
\item XCMS processing
\itemize{
\item (mzML files) -> xcms.findChromPeaks -> (optionally) xcms.adjustRtime -> xcms.groupChromPeaks -> (XCMSnExp)
\item [older versions of xcms] (mzML files) -> xcms.xcmsSet -> xcms.merge -> xcms.group -> xcms.retcor -> xcms.group -> (xset)
}
\item Fragmentation processing
\itemize{
\item ([xset/XCMSnExp], pa) -> frag4feature -> \strong{filterFragSpectra} -> averageAllFragSpectra -> createDatabase -> spectralMatching -> (sqlite spectral database)
}
}
}
\examples{

#read in MS data
msmsPths <- list.files(system.file("extdata", "lcms", "mzML", package="msPurityData"), full.names = TRUE, pattern = "MSMS")
ms_data = readMSData(msmsPths, mode = 'onDisk', msLevel. = 1)

#find peaks in each file
cwp <- CentWaveParam(snthresh = 5, noise = 100, ppm = 10, peakwidth = c(3, 30))
obj <- xcms::findChromPeaks(ms_data, param = cwp)
#obj <- xcms::xcmsSet(msmsPths)

#optionally adjust retention time
obj <- adjustRtime(obj, param = ObiwarpParam(binSize = 0.6))
#obj <- xcms::group(obj)
#obj <- xcms::retcor(obj)

#group features across samples
sg = rep(1, length(obj$sampleNames))
pdp <- PeakDensityParam(sampleGroups = sg, minFraction = 0, bw = 30)
obj <- groupChromPeaks(obj, param = pdp)
#obj <- xcms::group(obj)

#pa  <- purityA(msmsPths)
#pa <- frag4feature(pa, xset)
pa <- readRDS(system.file("extdata", "tests", "purityA",
                          "2_frag4feature_pa.rds", package="msPurity"))
pa <- filterFragSpectra(pa)

}
